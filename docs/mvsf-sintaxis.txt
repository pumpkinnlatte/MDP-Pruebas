% ==============================================================================
% ESPECIFICACIÓN TÉCNICA: FLUENTES DE ESTADO EN MDP-PROBLOG
% ==============================================================================

% 1. Declaración de un fluente de estado multivaluado (MVSF / ADS):

%    - Para declarar un fluente de estado se utiliza el predicado state_fluent/1 y state_fluent/2.
%    - args: 1. Predicado estrictamente con argumentos los cuales definan las propiedades del fluente de estado.
%            2. Constante que permite definir explícitamente si se desea modelar como booleano o multivaluado (bsf o ads).

%   Ej. Definición por inferencia (Automática):

        state_fluent(semaforo(X)) :- colores(X).

        1/3::colores(rojo);
        1/3::colores(amarillo);
        1/3::colores(verde) :- true.

%    - Lo que hace que el sistema distinga entre un BSF (Booleano) y un MVSF (Multivaluado) es el ORIGEN.
%    - Los valores de origen deben derivarse de disyunciones anotadas (nodos choice en la ClauseDB).
%    - El sistema crea los grupos extrayendo los identificadores del predicado base.

%   Ej. Definición explicita (Manual):

        state_fluent(semaforo(X), ads) :- colores().

        1/3::colores(rojo);
        1/3::colores(amarillo);
        1/3::colores(verde).

%   también es valido:

        colores(rojo);
        colores(amarillo);
        colores(verde).

%    - Cuando se define explícitamente el tipo de fluente mediante la constante 'ads', actúa el mecanismo de definición explícita.
%    - En este caso, el origen de los valores del fluente es irrelevante para el motor de inferencia. No importa si eran hechos independientes estáticos o probabilísticos; el sistema los empaquetará en un grupo mutuamente excluyente.

% 1.1 Un requisito para que el fluente se clasifique como multivaluado es que mínimo tenga 2 valores de origen declarados como predicados.

    Ej. Declaración inválida de un MVSF mediante inferencia:

        state_fluent(semaforo(X), ads) :- colores(X).

        colores(verde).

     - Al tener un único valor, el sistema NO DEBE DE PERMITIR la creación del fluente mediante una exepción. El modelo se declara como inválido
     
    Ej. Declaración inválida de un MSVF mediante definición explicita:

        state_fluent(semaforo(X), ads) : colores(X).

        colores(verde).

%    - Otro ejemplo inválido (Hardcoding sin dominio):

        state_fluent(semaforo(verde), ads).

%    - Como se puede observar, la única manera de declarar fluentes de estado multivaluados robustos es mediante una regla paramétrica.
%    - La explicación algorítmica de esto es que los fluentes multivaluados (ADS) requieren matemáticamente de un dominio de opciones para iterar en el sistema Mixed-Radix. Un grupo excluyente de 1 sola opción es una paradoja lógica (es una constante, no una variable estocástica).

% 2. Combinación y flexibilidad en la declaración de fluentes.

%    - Al ser ProbLog un lenguaje bastante flexible, debemos tener cuidado con la forma en la que se utiliza el sistema de reglas.
%    - El sistema utiliza la "Regla del Último Argumento" para procesar las combinaciones de orígenes lógicos.
%    - REGLA: En un predicado state_fluent(pred(Arg1, Arg2, ..., ArgN)), los argumentos del 1 al N-1 son tratados como IDENTIFICADORES ESTÁTICOS (Llave de grupo). El argumento N es tratado como el VALOR MUTUABLE (Dominio de la ADS).

%    Ej. Combinación correcta de orígenes (Identificador Estático + Valor Mutuable).

        state_fluent(marketed(X, Y)) :- person(X), marketing_type(Y).

        person(thiago).
        person(denis).
        person(fabio).
        person(liliane).

        1/3::marketing_type(television);
        1/3::marketing_type(internet);
        1/3::marketing_type(none).

%    - El ejemplo anterior obtiene como resultado lo siguiente:
%        1. Un grupo excluyente para cada entidad estática independiente declarada en person(X).
%        2. Cada grupo puede variar únicamente entre los valores del último argumento marketing_type(Y).
        
%    - Resultado en el FactorSpace:
        Grupo marketed(thiago):  [television, internet, none]
        Grupo marketed(denis):   [television, internet, none]
        Grupo marketed(fabio):   [television, internet, none]
        Grupo marketed(liliane): [television, internet, none]


% 2.1 Combinaciones Inválidas y Colapsos Estructurales

%    - ¿Qué sucede si intentamos combinar múltiples orígenes mutuamente excluyentes en una misma regla?

%    Ej. Declaración inválida (Múltiples estados mutuables en un mismo fluente):

        state_fluent(tv_state(X, Y, Z)) :- television(X), condition(Y), power(Z).

        television(one).
        
        0.5::condition(good); 0.5::condition(bad).
        0.5::power(on); 0.5::power(off).

%    - CÓMO FUNCIONA: Aplicando la regla del último argumento, el sistema toma X e Y como la llave estática, y Z como el único valor mutuable.
%    - RESULTADO:
        Grupo tv_state(one, good): [on, off]
        Grupo tv_state(one, bad):  [on, off]

%    - POR QUÉ NO SE DEBE HACER: El sistema ha "clonado" la televisión. Obliga al modelo a tener un estado de energía para cuando está buena, y simultáneamente otro estado de energía para cuando está mala. Destruye la independencia de las variables.

%    - SOLUCIÓN: Separar en reglas distintas: 
        state_fluent(tv_cond(X,Y)) :- television(X), condition(Y).
        state_fluent(tv_power(X,Z)) :- television(X), power(Z).

% 2.2 Combinaciones Geométricas mediante Términos Compuestos (Compound Terms)

%    - ¿Qué sucede si mi valor mutuable requiere estrictamente de dos o más parámetros combinados (como una coordenada X, Y)?

%    Ej. Declaración inválida de Coordenadas (Colapso por separación):

        state_fluent(pos(X, Y)) :- coord(X), coord(Y).

%    - RESULTADO: Tomará X como llave y Y como valor. Creará un grupo para X=1, otro para X=2, exigiendo que el robot exista en múltiples columnas a la vez.

%    Ej. Declaración Correcta mediante Empaquetamiento (Compound Term):

        state_fluent(pos(celda(X, Y))) :- coord(X), coord(Y).

%    - CÓMO FUNCIONA: El predicado pos/1 tiene un solo argumento: celda(X,Y). Al no haber argumentos previos (N-1 = 0), la llave de grupo es simplemente "pos". 

%    - RESULTADO ESPERADO: 
        Grupo pos: [celda(1,1), celda(1,2), celda(2,1), celda(2,2)]

%    - POR QUÉ FUNCIONA: El sistema empaqueta ambos orígenes (X e Y) dentro de un único nodo lógico en el último argumento. Esto garantiza que toda la coordenada bidimensional compita entre sí por la exclusión mutua, permitiendo que el robot ocupe un solo espacio a la vez.


% 3. Inferencia Estructural: El Paradigma de Agrupamiento por Cardinalidad

%    - En fluentes paramétricos con N argumentos, existe un problema de explosión combinatoria (2^N) si el motor intenta rastrear en el Abstract Syntax Tree (AST) si cada origen provino de un hecho estático o de una disyunción anotada.
%    - Para colapsar esta complejidad, MDP-ProbLog debe abandonar el intentar rastrear el origen de todos los argumentos y limitarle solo a buscar el último de ellos.

% 3.1 Restricción Semántica de los Argumentos Identificadores
%    - REGLA ESTRICTA: Los orígenes lógicos de los argumentos 1 al N-1 pueden ser hechos probabilisticos independientes o ADS pero esto no importará ya que solo se tomará en cuenta el origen del último argumento. 
%    - JUSTIFICACIÓN: Las entidades físicas de un MDP (ej. la existencia de un robot o una habitación) no pueden ser probabilísticas. Solo el estado de esas entidades (argumento N) puede someterse a incertidumbre.

% 3.1.1 Ultimo argumento
%    - El útlimo termino puede tener de origen una ADS o un hecho probabilistio independiente 

% 3.2 El Algoritmo de Inferencia (Resolución del 2^N)
%    - El motor delega el producto cartesiano al grounding de ProbLog, obteniendo una lista plana de todos los fluentes de estado válidos.
%    - Se extrae la llave estática (args[:-1]) de cada fluente aterrizado.
%    - Se agrupan todos los fluentes que comparten la misma llave en un diccionario de listas.
%    - ESTRICTAMENTE SE VERIFICA SI EL ORIGEN DEL TERMINO N ES UNA DISYUNCIÓN ANOTADA
%    - SI SE VERIFICA QUE ES UNA DISYUNCIÓN ANOTADA:
%        * Si el origen del termino es una disyunción anotada, por ente, estrictamente debe tener minimo 2 elementos-> Es una Disyunción Anotada de Estado (ADS).
%    - SI SE DETECTA QUE EL ORIGEN NO ES UNA DISYUNCIÓN, SI NO QUE ES UN HECHO PROBABILISTICO -> Es un Fluente de estado Booleano (BSF)

%    Ej. Aplicación del algoritmo en un fluente complejo de 3 argumentos:
        state_fluent(sensor(X, Y, Z)) :- habitacion(X), dispositivo(Y), medicion(Z).

        habitacion(sala).
        habitacion(cocina).

        dispositivo(termometro).
        dispositivo(humo).

        1/3::medicion(alto);
        1/3::medicion(bajo);
        1/3::medicion(none).

%    - PASO 1: Lista plana aterrizada devuelta por ProbLog (El Producto Cartesiano):
        sensor(sala, termometro, alto)
        sensor(sala, termometro, bajo)
        sensor(sala, termometro, none)

        sensor(sala, humo, alto)
        sensor(sala, humo, bajo)
        sensor(sala, humo, none)

        sensor(cocina, termometro, alto)
        sensor(cocina, termometro, bajo)
        sensor(cocina, termometro, none)

        sensor(cocina, humo, alto)
        sensor(cocina, humo, bajo)
        sensor(cocina, humo, none)

%    - PASO 2: Agrupamiento por llave estática (Extrayendo args[:-1]):
        Llave: sensor(sala, termometro)   -> Valores: [alto, bajo, none]
        Llave: sensor(sala, humo)         -> Valores: [alto, bajo, none]
        Llave: sensor(cocina, termometro) -> Valores: [alto, bajo, none]
        Llave: sensor(cocina, humo)       -> Valores: [alto, bajo, none]

%    - PASO 3: Inferencia Automática (Regla de Cardinalidad):
        sensor(sala, termometro)   -> Cardinalidad = 3 -> Se infiere como Grupo ADS.
        sensor(sala, humo)         -> Cardinalidad = 3 -> Se infiere como Grupo ADS.
        sensor(cocina, termometro) -> Cardinalidad = 3 -> Se infiere como Grupo ADS.
        sensor(cocina, humo)       -> Cardinalidad = 3 -> Se infiere como Grupo ADS.

%    - CONCLUSIÓN DEL EJEMPLO: 
%      Aunque el predicado tiene 3 argumentos y múltiples orígenes, el motor de MDP-ProbLog 
%      jamás tuvo que analizar el código fuente para saber si "medicion" era probabilística 
%      o si "habitacion" era estática. Simplemente agrupó los datos resultantes por su llave 
%      (los primeros N-1 argumentos) y contó sus elementos. La complejidad de inferir el 
%      tipo de fluente se reduce a verificar el origen del utlimo argumento (ADS O Hechos independientes).

%    Ej. Aplicación del algoritmo en un fluente que se infiere como Binario (BSF):
        state_fluent(alarma(X, Y)) :- zona(X), estado_alarma(Y).

        zona(norte).
        zona(sur).

        % El estado solo tiene una única opción declarada (origen probabilístico o determinista)
        0.1::estado_alarma(activada).

%    - PASO 1: Lista plana aterrizada devuelta por ProbLog (El Producto Cartesiano):
        alarma(norte, activada)
        alarma(sur, activada)

%    - PASO 2: Agrupamiento por llave estática (Extrayendo args[:-1]):
        Llave: alarma(norte) -> Valores: [activada]
        Llave: alarma(sur)   -> Valores: [activada]

%    - PASO 3: Inferencia Automática (Filtro de Vocabulario Extensional):

        sensor(sala, termometro) -> El último argumento ('alto', 'bajo', 'none') SÍ existe en el vocabulario de exclusión mutua -> Se infiere como Grupo ADS.
        alarma(norte) -> El último argumento ('activada') NO existe en el vocabulario de exclusión mutua -> Se infiere como BSF.

%    - CONCLUSIÓN DEL EJEMPLO: 
%      Como cada llave estática solo tiene asociado un (1) único valor posible en su dominio, 
%      el motor matemático deduce que no existen opciones categóricas que compitan entre sí por la 
%      exclusión mutua. En consecuencia, el sistema procesa la "activación" como una variable de 
%      Bernoulli tradicional (Verdadero/Falso), donde la ausencia del término durante la inferencia 
%      se interpretará implícitamente como el estado Falso (ej. la alarma está apagada).


% 3.3 Definición Explícita con Múltiples Argumentos (El modificador 'ads')
%    - ¿Qué sucede si el usuario utiliza múltiples argumentos pero fuerza la clasificación categórica mediante el predicado state_fluent/2?
%    - El algoritmo de extracción sigue siendo el mismo (agrupamiento por la llave estática args[:-1]).
%    - La diferencia radica en la Validación: el sistema ignorará por completo el origen de los datos (no exigirá que provengan de disyunciones anotadas), PERO exigirá estrictamente que la cardinalidad final del grupo sea mayor o igual a 2.

%    Ej. Declaración explícita VÁLIDA (Orígenes estáticos forzados a grupo categórico):
        state_fluent(clima(X, Y, Z), ads) :- region(X), mes(Y), tipo(Z).

        region(norte).
        
        mes(enero).

        % Observar que son hechos estáticos, no disyunciones (no hay X::Y)
        tipo(soleado).
        tipo(lluvioso).

%    - PASO 1: Lista plana aterrizada devuelta por ProbLog:
        clima(norte, enero, soleado)
        clima(norte, enero, lluvioso)

%    - PASO 2: Agrupamiento por llave estática (Extrayendo args[:-1]):
        Llave: clima(norte, enero) -> Valores: [soleado, lluvioso]

%    - PASO 3: Validación Explícita:
        clima(norte, enero) -> Cardinalidad = 2 -> Cumple con la restricción matemática de la etiqueta 'ads'. El sistema lo acepta y empaqueta el grupo.

%    Ej. Declaración explícita INVÁLIDA (Colapso por cardinalidad insuficiente):
        state_fluent(clima(X, Y, Z), ads) :- region(X), mes(Y), tipo(Z).

        region(sur).
        mes(febrero).

        tipo(nublado). % Única opción declarada

%    - PASO 1 y 2 (Agrupamiento):
        Llave: clima(sur, febrero) -> Valores: [nublado]

%    - PASO 3: Validación Explícita:
        clima(sur, febrero) -> Cardinalidad = 1.

%    - CONCLUSIÓN DEL EJEMPLO: 
%      ¡EXCEPCIÓN! Aunque el usuario forzó la declaración usando la etiqueta 'ads', 
%      la matemática de bases mixtas (Mixed-Radix) requiere estrictamente una base 
%      b >= 2 para poder iterar un grupo mutuamente excluyente. El motor de MDP-ProbLog 
%      prioriza la integridad de la Ecuación de Bellman sobre la etiqueta manual del usuario. 
%      Al detectar un grupo etiquetado como 'ads' con un solo elemento, el motor rechaza 
%      el modelo y detiene la compilación para evitar un colapso algorítmico posterior.


% 4. ALCANCE, FLEXIBILIDAD Y LIMITACIONES DEL FRAMEWORK (SINTAXIS Y ESCALABILIDAD)

%    - MDP-ProbLog está diseñado para resolver Procesos de Decisión de Markov Factorizados (Factored MDPs) de horizonte infinito. 
%    - A diferencia de los MDPs tradicionales que sufren la "Maldición de la Dimensionalidad" al requerir la definición manual de cada estado , este framework utiliza programación lógica probabilística (ProbLog) para comprimir la representación del sistema.

% 4.1 Flexibilidad: El Poder de la Representación Relacional
%    - ALCANCE: El uso de lógica de primer orden permite definir espacios de estado masivos mediante reglas paramétricas abstractas (Plantillas).
%    - En lugar de declarar explícitamente "persona_A_tiene_TV", "persona_B_tiene_Radio", el usuario simplemente declara el conocimiento base (Background Knowledge) y el motor genera el producto cartesiano automáticamente.
%    - FLEXIBILIDAD ESTRUCTURAL: El framework soporta de manera nativa espacios de estado de Bases Mixtas (Mixed-Radix). Es capaz de orquestar simultáneamente variables booleanas puras (BSF) para sensores independientes, y variables categóricas (ADS) para propiedades mutuamente excluyentes, aislando matemáticamente cada sub-dominio.

% 4.2 Limitación Sintáctica: La Pérdida de la Libertad Posicional
%    - EL COMPROMISO (TRADE-OFF): En Prolog estándar, el orden de los argumentos en un predicado no altera su semántica (ej. relacion(Llave, Valor) es igual de válido que relacion(Valor, Llave)).
%    - LA LIMITACIÓN: Para lograr que MDP-ProbLog pueda inferir la topología geométrica del MDP en tiempo constante O(1) sin rastrear variables en el Árbol de Sintaxis (AST), el framework impone una restricción sintáctica estricta: La "Regla del Último Argumento".
%    - CONSECUENCIA: El diseñador del modelo pierde la libertad posicional. Si un usuario modela un estado donde el dominio mutuable está en el primer argumento (ej. state_fluent(color(Valor, Objeto))), la arquitectura actual colapsará o lo inferirá erróneamente como BSF. El usuario está obligado a estructurar su mente y su código hacia el modelo: propiedad(Entidad, ..., Valor).

% 4.3 Limitación Computacional: El Cuello de Botella del "Grounding"
%    - ALCANCE TEÓRICO vs PRÁCTICO: Aunque la sintaxis permite representar MDPs con millones de estados usando unas pocas líneas de código, el solucionador subyacente (ProbLog) no opera directamente sobre lógica de primer orden.
%    - LA LIMITACIÓN: Antes de ejecutar la Ecuación de Bellman, ProbLog realiza un proceso de "Grounding" (Aterrizaje), convirtiendo las reglas abstractas en un circuito booleano proposicional gigante.
%    - CONSECUENCIA: Si el diseñador del modelo abusa de la flexibilidad relacional introduciendo demasiadas entidades en el conocimiento base (ej. 100 personas, 50 canales de marketing, 10 instantes de tiempo), el producto cartesiano de las llaves estáticas provocará un colapso de memoria RAM (State Space Explosion) durante la fase de compilación (ClauseDB), mucho antes de que inicie la iteración de valor.

% 4.4 La Carga de la Inercia (El Problema del Marco Generalizado)
%    - FLEXIBILIDAD DE TRANSICIÓN: El framework permite definir la probabilidad de un estado futuro condicionado únicamente a un subconjunto de variables del estado actual , lo que reduce drásticamente los parámetros de transición que el usuario debe escribir.
%    - LA LIMITACIÓN: El lenguaje probabilístico subyacente asume la suposición del mundo cerrado (Closed-World Assumption). Lo que no se declara explícitamente que cambia o se mantiene, se vuelve falso por defecto.
%    - CONSECUENCIA: MDP-ProbLog carece de un motor de inercia nativo. El framework transfiere al usuario la carga semántica de definir explícitamente los "Axiomas de Marco". Si un dominio mutuable no se ve afectado por una acción particular, el usuario debe escribir reglas redundantes (ej. 1.0::estado(1) :- estado(0), accion_irrelevante) para evitar que las variables colapsen a su estado base durante las iteraciones de transición.